#define LOG_TAG "lcd_gc9505"
#define ELOG_OUTPUT_LVL ELOG_LVL_ERROR
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <getopt.h>
#include <sys/ioctl.h>
#include <kernel/io.h>
#include <kernel/types.h>
#include <kernel/vfs.h>
#include <kernel/lib/console.h>
#include <kernel/elog.h>
#include <kernel/lib/fdt_api.h>
#include <kernel/module.h>
#include <hcuapi/gpio.h>
#include <hcuapi/pinpad.h>
#include <hcuapi/pinmux.h>
#include <kernel/io.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include "../lcd_main.h"
/*
*	TIME: 2022 11 12
	lcd-gc9505{
		spi-gpio-sck	= <PINPAD_T01>;
		spi-gpio-mosi	= <PINPAD_T02>;
		spi-gpio-cs		= <PINPAD_T04>;
		default-off;
		status = "okay";
	};
	lcd{
		lcd-map-name = "lcd-gc9505";
		default-off;
		status = "okay";
	};
*/

static void gc9505_spi_sends_data(unsigned char *data,unsigned char len);
static void gc9505_write_commands(unsigned char *data,unsigned char len);
static void gc9505_write_data(unsigned char data);
static void gc9505_write_command(unsigned short cmds);
static int gc9505_display_init(void);
static void lcd_reset(void);

#define LCD_SPI_DATA_MAX_SIZE 		52
#define LCD_SPI_INIT_END		0xFFFF
#define LCD_SPI_DELAY			0xFFFE
typedef struct {
	unsigned short cmd;
	unsigned char data[LCD_SPI_DATA_MAX_SIZE];
	unsigned char len;//If the value of len is LCD_SPI_DELAY, the function of len is delay, otherwise it is the length of the command
} lcd_init_cmd_t;

typedef struct gc9505_dev{
	u32 spi_clk_num;
	u32 spi_clk_vaild_edge;
	u32 spi_cs_num;
	u32 spi_cs_polar;  
	u32 spi_mosi_num;
	u32 spi_miso_num;
	u32 spi_is_9bit;
	u32 spi_mode;
	u32 lcd_reset_num;
	u32 lcd_reset_polar;
	u32 lcd_stbyb_num;
	u32 lcd_stbyb_polar;
	u32 cur_type;
}gc9505_dev_t;

static struct gc9505_dev gc9505dev;

static int gc9505_display_init(void)
{
	gpio_configure(gc9505dev.spi_clk_num,	GPIO_DIR_OUTPUT);
	gpio_configure(gc9505dev.spi_cs_num,	GPIO_DIR_OUTPUT);
	gpio_configure(gc9505dev.spi_mosi_num,	GPIO_DIR_OUTPUT);
	gpio_configure(gc9505dev.lcd_reset_num,	GPIO_DIR_OUTPUT);

	lcd_reset();

	lcd_init_cmd_t gc9505_init_cmds[]={
		{0xF0,{0x55,0xAA,0x52,0x08,0x00},5},
		{0xF6,{0x5A,0x87},2},
		{0xC1,{0x3F},1},
		{0xC2,{0x0E},1},
		{0xC6,{0xFf},1},
		{0xC9,{0x10},1},
		{0xCD,{0x25},1},
		{0xfa,{0x08,0x08,0x08,0x04},4},
		{0xF8,{0x8A},1},
		{0x71,{0xDF},1},
		{0x72,{0xDF},1},
		{0x73,{0x44,0x44},2},
		{0x97,{0xEE},1},
		{0x83,{0x93},1},
		{0xA3,{0x22},1},
		{0x86,{0x99,0xa3,0xa3,0x71},4},
		{0xFD,{0x28,0x28,0x00},3},
		{0xAC,{0x45},1},
		{0xA7,{0x47},1},
		{0xA0,{0xAA},1},
		{0x9A,{0x58},1},
		{0x9B,{0x77},1},
		{0x82,{0x0E,0x0E},2},
		{0xB1,{0x04},1},
		{0x80,{0x6F},1},
		{0x91,{0x55,0x55},2},
		{0x7A,{0x13,0x1A},2},
		{0x7B,{0x13,0x1A},2},
		{0x3A,{0x50},1},
		{0x6D,{0x00,0x1F,0x19,0x1A,0x10,0x0E,0x0C,0x0A,0x02,0x08,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x07,0x01,0x09,0x0B,0x0D,0x0F,0x1A,0x19,0x1F,0x00},32},
		{0x64,{0x28,0x04,0x02,0x7C,0x03,0x03,0x28,0x03,0x02,0x7D,0x03,0x03,0x7A,0x7A,0x7A,0x7A},16},
		{0x65,{0x28,0x02,0x02,0x7E,0x03,0x03,0x28,0x01,0x02,0x7F,0x03,0x03,0x7A,0x7A,0x7A,0x7A},16},
		{0x66,{0x28,0x00,0x02,0x80,0x03,0x03,0x20,0x01,0x02,0x81,0x03,0x03,0x7A,0x7A,0x7A,0x7A},16},
		{0x67,{0x20,0x02,0x02,0x82,0x03,0x03,0x20,0x03,0x02,0x83,0x03,0x03,0x7A,0x7A,0x7A,0x7A},16},
		{0x68,{0x77,0x08,0x06,0x08,0x05,0x7A,0x7A,0x08,0x06,0x08,0x05,0x7A,0x7A},13},
		{0x60,{0x28,0x06,0x7A,0x7A,0x28,0x05,0x7A,0x7A},8},
		{0x63,{0x22,0x7E,0x7A,0x7A,0x22,0x7F,0x7A,0x7A},8},
		{0x69,{0x14,0x22,0x14,0x22,0x14,0x22,0x08},7},
		{0x6B,{0x07},1},
		{0xD1,{0x00,0x00,0x00,0x0E,0x00,0x20,0x00,0x35,0x00,0x44,0x00,0x63,0x00,0x7E,0x00,0xAA,0x00,0xD6,0x01,0x15,0x01,0x4D,0x01,0xAD,0x02,0x00,0x02,0x02,0x02,0x4F,0x02,0xAD,0x02,0xE8,0x03,0x36,0x03,0x6B,0x03,0xa5,0x03,0xB0,0x03,0xF0,0x03,0xF5,0x03,0xFA,0x03,0xFD,0x03,0xFF},52},
		{0xD2,{0x00,0x00,0x00,0x0E,0x00,0x20,0x00,0x35,0x00,0x44,0x00,0x63,0x00,0x7E,0x00,0xAA,0x00,0xD6,0x01,0x15,0x01,0x4D,0x01,0xAD,0x02,0x00,0x02,0x02,0x02,0x4F,0x02,0xAD,0x02,0xE8,0x03,0x36,0x03,0x6B,0x03,0xa5,0x03,0xB0,0x03,0xF0,0x03,0xF5,0x03,0xFA,0x03,0xFD,0x03,0xFF},52},
		{0xD3,{0x00,0x00,0x00,0x0E,0x00,0x20,0x00,0x35,0x00,0x44,0x00,0x63,0x00,0x7E,0x00,0xAA,0x00,0xD6,0x01,0x15,0x01,0x4D,0x01,0xAD,0x02,0x00,0x02,0x02,0x02,0x4F,0x02,0xAD,0x02,0xE8,0x03,0x36,0x03,0x6B,0x03,0xa5,0x03,0xB0,0x03,0xF0,0x03,0xF5,0x03,0xFA,0x03,0xFD,0x03,0xFF},52},
		{0xD4,{0x00,0x00,0x00,0x0E,0x00,0x20,0x00,0x35,0x00,0x44,0x00,0x63,0x00,0x7E,0x00,0xAA,0x00,0xD6,0x01,0x15,0x01,0x4D,0x01,0xAD,0x02,0x00,0x02,0x02,0x02,0x4F,0x02,0xAD,0x02,0xE8,0x03,0x36,0x03,0x6B,0x03,0xa5,0x03,0xB0,0x03,0xF0,0x03,0xF5,0x03,0xFA,0x03,0xFD,0x03,0xFF},52},
		{0xD5,{0x00,0x00,0x00,0x0E,0x00,0x20,0x00,0x35,0x00,0x44,0x00,0x63,0x00,0x7E,0x00,0xAA,0x00,0xD6,0x01,0x15,0x01,0x4D,0x01,0xAD,0x02,0x00,0x02,0x02,0x02,0x4F,0x02,0xAD,0x02,0xE8,0x03,0x36,0x03,0x6B,0x03,0xa5,0x03,0xB0,0x03,0xF0,0x03,0xF5,0x03,0xFA,0x03,0xFD,0x03,0xFF},52},
		{0xD6,{0x00,0x00,0x00,0x0E,0x00,0x20,0x00,0x35,0x00,0x44,0x00,0x64,0x00,0x7E,0x00,0xAA,0x00,0xD6,0x01,0x15,0x01,0x4D,0x01,0xAD,0x02,0x00,0x02,0x02,0x02,0x4F,0x02,0xAD,0x02,0xE8,0x03,0x36,0x03,0x6B,0x03,0xa5,0x03,0xB0,0x03,0xF0,0x03,0xF5,0x03,0xFA,0x03,0xFD,0x03,0xFF},52},
		{0x11,{0x00},1},
		{LCD_SPI_DELAY,{0x00},0x78},
		{0x29,{0x00},1},
		{LCD_SPI_DELAY,{0x00},0x78},
		{LCD_SPI_INIT_END,{0},0},
	};
	lcd_init_cmd_t *lcd_init_cmd;
	lcd_init_cmd=gc9505_init_cmds;

	log_d("lcd init\n");

	while(lcd_init_cmd->cmd!=LCD_SPI_INIT_END&&lcd_init_cmd!=NULL)
	{
		if(lcd_init_cmd->cmd==LCD_SPI_DELAY)
		{
			usleep(lcd_init_cmd->len*1000);
		}
		else
		{
			gc9505_write_command(lcd_init_cmd->cmd);
			gc9505_spi_sends_data(lcd_init_cmd->data,lcd_init_cmd->len&0x3F);
		}
		lcd_init_cmd++;
	}
	return 0;
}

static void gpio_spi_set_mosi(unsigned char data)
{
	lcd_gpio_set_output(gc9505dev.spi_mosi_num,(bool)data);
}

static void gpio_spi_generate_clk(void)
{
	if(gc9505dev.spi_clk_vaild_edge == 1)//1 
		lcd_gpio_set_output(gc9505dev.spi_clk_num,1);
	else
		lcd_gpio_set_output(gc9505dev.spi_clk_num,0);
	usleep(2);
	if(gc9505dev.spi_clk_vaild_edge == 1)//1 
		lcd_gpio_set_output(gc9505dev.spi_clk_num,0);
	else
		lcd_gpio_set_output(gc9505dev.spi_clk_num,1);
}
static void gpio_spi_enable_cs(void)//==0
{
	if(gc9505dev.spi_cs_polar == 0)	
		lcd_gpio_set_output(gc9505dev.spi_cs_num,0);
	else
		lcd_gpio_set_output(gc9505dev.spi_cs_num,1);
}

static void gpio_spi_disable_cs(void)
{
	if(gc9505dev.spi_cs_polar == 0)
		lcd_gpio_set_output(gc9505dev.spi_cs_num,1);//cs
	else
		lcd_gpio_set_output(gc9505dev.spi_cs_num,0);//cs
}

static void gpio_spi_init_clk(void)
{
	if(gc9505dev.spi_clk_vaild_edge == 1)//1 //==1
		lcd_gpio_set_output(gc9505dev.spi_clk_num,0);//sck
	else
		lcd_gpio_set_output(gc9505dev.spi_clk_num,1);//sck
		
}

static void lcd_gpio_spi_config_write(unsigned char bit_9,unsigned char cmd)
{
	int i=0;
	unsigned char cmd_val = 0;
	gpio_spi_disable_cs();//cs
	usleep(10);
	gpio_spi_init_clk();//sck
	gpio_spi_enable_cs();
	usleep(2);
	if(gc9505dev.spi_is_9bit == 1)
	{
		gpio_spi_set_mosi(bit_9);//sda dat=0
		usleep(3);
		gpio_spi_generate_clk();
	}
	for(i=8;i>0;i--){
		cmd_val = (cmd>>(i-1))&0x1;
		gpio_spi_set_mosi(cmd_val);
		usleep(2);
		gpio_spi_generate_clk();
	}
	usleep(2);
	gpio_spi_disable_cs();
	gpio_spi_set_mosi(0);
	usleep(10);
}

static void gc9505_write_data(unsigned char data)
{
	lcd_gpio_spi_config_write(1,data);
}

static void gc9505_spi_sends_data(unsigned char *data,unsigned char len)
{
	int i=len;
	do{
		gc9505_write_data(*data++);
	}
	while(i--);
}

static void gc9505_write_command(unsigned short cmds)
{
	lcd_gpio_spi_config_write(0,(unsigned char)cmds);
}

static void gc9505_write_commands(unsigned char *data,unsigned char len)
{
	int i=len;
	do{
		gc9505_write_command(*data++);
	}
	while(i--);
}

static void lcd_reset(void)
{
	if(gc9505dev.lcd_reset_num!=0xff)
	{
		lcd_gpio_set_output(gc9505dev.lcd_reset_num,1);
		usleep(500*1000);
		lcd_gpio_set_output(gc9505dev.lcd_reset_num,0);
		usleep(500*1000);
		lcd_gpio_set_output(gc9505dev.lcd_reset_num,1);
		usleep(500*1000);
	}
}

static struct lcd_map_list gc9505_map = {
	.map = {
		.lcd_init = gc9505_display_init,
		.name = "lcd-gc9505",
	}
};

static int gc9505_probe(const char *node)
{
	int np = fdt_node_probe_by_path(node);

	if(np < 0){
		goto error;
	}

	memset(&gc9505dev,0,sizeof(struct gc9505_dev));

	gc9505dev.spi_clk_num = PINPAD_INVALID;//lcddrv->gpio_spi_config.sck;
	gc9505dev.spi_clk_vaild_edge=1;
	gc9505dev.spi_cs_polar=0;
	gc9505dev.spi_is_9bit=1;
	gc9505dev.spi_cs_num = PINPAD_INVALID;//lcddrv->gpio_spi_config.cs;
	gc9505dev.spi_mosi_num = PINPAD_INVALID;//lcddrv->gpio_spi_config.mosi;
	gc9505dev.spi_miso_num = PINPAD_INVALID;//lcddrv->gpio_spi_config.miso;
	gc9505dev.lcd_stbyb_num = PINPAD_INVALID;//lcddrv->gpio_spi_config.stbyb;
	gc9505dev.lcd_stbyb_polar = 0;
	gc9505dev.lcd_reset_num  = PINPAD_INVALID;
#if 0
	gc9505dev.spi_clk_num=PINPAD_T01;
	gc9505dev.spi_clk_vaild_edge=1;
	gc9505dev.spi_cs_polar=0;
	gc9505dev.spi_is_9bit=1;
	gc9505dev.spi_cs_num=PINPAD_T04;
	gc9505dev.spi_mosi_num=PINPAD_T02;
	gc9505dev.lcd_reset_num=PINPAD_T05;
	gc9505dev.lcd_reset_polar=0;
#endif
	fdt_get_property_u_32_index(np, "reset", 			0, &gc9505dev.lcd_reset_num);
	fdt_get_property_u_32_index(np, "spi-gpio-sck", 	0, &gc9505dev.spi_clk_num);
	fdt_get_property_u_32_index(np, "spi-gpio-mosi", 	0, &gc9505dev.spi_mosi_num);
	fdt_get_property_u_32_index(np, "spi-gpio-miso", 	0, &gc9505dev.spi_miso_num);
	fdt_get_property_u_32_index(np, "spi-gpio-cs", 		0, &gc9505dev.spi_cs_num);
	fdt_get_property_u_32_index(np, "spi-gpio-stbyb", 	0, &gc9505dev.lcd_stbyb_num);
	log_d("gc9505dev.lcd_stbyb_num = %d %d %d %d\n",gc9505dev.spi_clk_num,gc9505dev.spi_mosi_num,gc9505dev.spi_cs_num,gc9505dev.lcd_stbyb_num);

	int default_off = 0;
	fdt_get_property_u_32_index(np, "default-off", 	0, &default_off);
	if(default_off ==0)
		gc9505_display_init();

	gc9505_map.map.default_off_val = default_off;
	lcd_map_register(&gc9505_map);
error:
	return 0;	
}

static int gc9505_init(void)
{
	gc9505_probe("/hcrtos/lcd-gc9505");
	return 0;
}

module_driver(gc9505, gc9505_init, NULL, 2)
